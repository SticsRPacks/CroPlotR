---
output: github_document
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: 72
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# CroPlotR

<!-- badges: start -->

[![Codecov test
coverage](https://codecov.io/gh/SticsRPacks/CroPlotR/branch/master/graph/badge.svg)](https://app.codecov.io/gh/SticsRPacks/CroPlotR?branch=master)
[![R-CMD-check](https://github.com/SticsRPacks/CroPlotR/actions/workflows/check-standard.yaml/badge.svg?branch=main)](https://github.com/SticsRPacks/CroPlotR/actions/workflows/check-standard.yaml)
[![DOI](https://zenodo.org/badge/263962392.svg)](https://zenodo.org/badge/latestdoi/263962392)

<!-- badges: end -->

`CroPlotR` aims at the standardization of the process of analyzing the outputs from crop models such as 
[STICS](https://www6.paca.inrae.fr/stics_eng/), [APSIM](https://www.apsim.info/) or really any model.

Its use does not need any particular adaptation if your model has been wrapped with the 
[CroptimizR](https://github.com/SticsRPacks/CroptimizR) package thanks to the use of the `cropr_simulation` standard of data representation (see section [Data structure](#13-data-structure)).

If you want to be notified when a new release of this package is made, you can tick the Releases box in the "Watch / Unwatch =\> Custom" menu
at the top right of [this page](https://github.com/SticsRPacks/CroPlotR).

## Table of Contents


- [CroPlotR](#croplotr)
  - [Table of Contents](#table-of-contents)
  - [1. Installation](#1-installation)
  - [2. Introduction](#2-introduction)
  - [3. Dynamic plots](#3-dynamic-plots)
    - [3.1. Simple dynamic plot](#31-simple-dynamic-plot)
    - [3.2. Observations](#32-observations)
    - [3.3. Filter variables](#33-filter-variables)
    - [3.4. Successive situations](#34-successive-situations)
    - [3.5. Overlaying variables](#35-overlaying-variables)
  - [4. Scatter plots](#4-scatter-plots)
    - [4.1. Simple scatter plot](#41-simple-scatter-plot)
    - [4.2. Plotting residuals](#42-plotting-residuals)
    - [4.3. Grouping situations](#43-grouping-situations)
    - [4.4. Reference variable on the x-axis](#44-reference-variable-on-the-x-axis)
    - [4.5. Different shapes for situations](#45-different-shapes-for-situations)
  - [5. Comparing model versions](#5-comparing-model-versions)
  - [6. Error bars](#6-error-bars)
  - [7. Intercrops](#7-intercrops)
  - [8. Plot saving](#8-plot-saving)
  - [9. Plot extraction](#9-plot-extraction)
  - [10. Statistics](#10-statistics)
    - [10.1. Simple case](#101-simple-case)
    - [10.2. Several groups](#102-several-groups)
    - [10.3. Statistics plot](#103-statistics-plot)
  - [11. Data manipulation](#11-data-manipulation)
  - [12. Tools](#12-tools)
    - [12.1. Interactivity with ggplotly](#121-interactivity-with-ggplotly)
    - [12.2. Combining plots with patchwork](#122-combining-plots-with-patchwork)
  - [13. Data structure](#13-data-structure)
  - [14. Finding help](#14-finding-help)
  - [15. Citation](#15-citation)

## 1. Installation

You can install the released version of CroPlotR from [Github](https://github.com/SticsRPacks/CroPlotR) either using
`devtools` or the more lightweight `remotes` package:

-   With `devtools`

```{r eval=FALSE}
devtools::install_github("SticsRPacks/CroPlotR@*release")
```

-   With `remotes`

```{r eval=FALSE}
# install.packages("remotes")
remotes::install_github("SticsRPacks/CroPlotR@*release")
```

## 2. Introduction

Only one function is exported for plots [`plot()`](https://sticsrpacks.github.io/CroPlotR/reference/plot.cropr_simulation.html)
(and its alias `autoplot()`), and one for the statistics [`summary()`](https://sticsrpacks.github.io/CroPlotR/reference/summary.cropr_simulation.html).
These functions should be the only one you need for all your plots and summary statistics. Additional ones are provided to simplify the
manipulation of simulated data (see section [Data manipulation](#11-data-manipulation)).

In the following, an example using the STICS crop model is presented. If you want to use another model for which a wrapper has been designed for
the [CroptimizR](https://github.com/SticsRPacks/CroptimizR) package, just consider defining the `sim` variable used in the examples below as
`sim <- result$sim_list`, where `result` is the list returned by your model wrapper. Examples of use of CroPlotR with Stics and APSIM model
wrappers can be found in [CroptimizR's website](https://sticsrpacks.github.io/CroptimizR/) (see Articles tab).

In the following examples, we use the `sim` and `obs` objects, which contain simulations and observations for two situations:

-   a Pea in sole crop
-   a Wheat in sole crop

We also use an intercrop situation with Wheat and Pea together, stored in `sim_intercrop` and `obs_intercrop`.

<details><summary>Code to import the data</summary>

To reproduce the data used in this file, you can use the following code snippet. It will import the data from an example simulation from the STICS model.

```{r, include = FALSE}
# Importing an example with three situations with observation:
workspace <- system.file(
  file.path("extdata", "stics_example_1"),
  package = "CroPlotR"
)

situations <- SticsRFiles::get_usms_list(
  file = file.path(workspace, "usms.xml")
)

usms_sole_crop <- c("SC_Pea_2005-2006_N0", "SC_Wheat_2005-2006_N0")
usms_intercrop <- c("IC_Wheat_Pea_2005-2006_N0")

sim <- SticsRFiles::get_sim(
  workspace = workspace,
  usms_file = file.path(workspace, "usms.xml"),
  usm = usms_sole_crop
)

sim_intercrop <- SticsRFiles::get_sim(
  workspace = workspace,
  usms_file = file.path(workspace, "usms.xml"),
  usm = usms_intercrop
)

obs <- SticsRFiles::get_obs(
  workspace = workspace,
  usm = usms_sole_crop,
  usms_file = file.path(workspace, "usms.xml")
)

obs_intercrop <- SticsRFiles::get_obs(
  workspace = workspace,
  usm = usms_intercrop,
  usms_file = file.path(workspace, "usms.xml")
)

workspace_2 <- system.file(
  file.path("extdata", "stics_example_successive"),
  package = "CroPlotR"
)

situations <- SticsRFiles::get_usms_list(
  file = file.path(workspace_2, "usms.xml")
)

sim_rot <- SticsRFiles::get_sim(
  workspace = workspace_2,
  usm = situations,
  usms_file = file.path(workspace_2, "usms.xml")
)

# Generate synthetic data mimicking the output of a simulation from a newer model version (for illustration purposes)
sim2 <- sim
for (sit in names(sim2)) {
  sim2[[sit]]$lai_n <- sim[[sit]]$lai_n * 1.1
  sim2[[sit]]$masec_n <- sim[[sit]]$masec_n * 1.1
  sim2[[sit]]$mafruit <- sim[[sit]]$mafruit * 1.1
}

# Write a .RData file for reproducibility for the users
save(
  sim, sim2, sim_intercrop, obs, obs_intercrop, sim_rot,
  file = "inst/extdata/readme_sim_obs_example.RData"
)
```

```{r}
library(CroPlotR)
rdata_path <- system.file(file.path("extdata", "readme_sim_obs_example.RData"), package = "CroPlotR")
load(rdata_path)
```

</details>

## 3. Dynamic plots

### 3.1. Simple dynamic plot

Here is an application of dynamic plots. By default, the plot function generate plots for all the variables and situations included in the data structure provided (in this example two variables, named `lai_n` and `masec_n`, and two situations, named `SC_Pea_2005-2006_N0` and `SC_Wheat_2005-2006_N0`:

```{r}
plot(sim)
```

### 3.2. Observations

We can also add observations to the dynamic plots by passing observed values for the variables and situations considered using the `obs` argument:

```{r}
plot(sim, obs = obs)
```

Note that it is mandatory to explicitly name the `obs` argument (`obs = ...`).

### 3.3. Filter variables

By default, all variables are returned by `plot()`, but you can filter them using the `var` argument:

```{r}
plot(sim, obs = obs, var = c("lai_n"))
```

### 3.4. Successive situations

It is possible to aggregate plots of multiple situations on the same
graph when situations follow one another over time. This can be done
using the `successive` parameter (used with three situations named `demo_Wheat1`, `demo_BareSoil2` and `demo_maize3` in this example):

```{r}
plot(
  sim_rot,
  var = c("resmes", "masec_n"),
  successive = list(list("demo_Wheat1", "demo_BareSoil2", "demo_maize3"))
)
```

### 3.5. Overlaying variables

We can also overlay variables thanks to the `overlap` parameter with
dynamic plots.

```{r}
plot(sim, obs = obs, overlap = list(list("lai_n", "masec_n")))
```

> Note that it is not possible to scale the variables right now from the
> plot function (see
> [issue](https://github.com/SticsRPacks/CroPlotR/issues/2)). If you
> want to do so, you are encouraged to scale before the plotting
> function, and to add a second axis using
> [sec_axis](https://ggplot2.tidyverse.org/reference/sec_axis.html) on
> the resulting plot.

## 4. Scatter plots

### 4.1. Simple scatter plot

Scatter plots can also be generated using the same plot function. By default they plot simulated against observed values for the different variables:

```{r}
plots <- plot(sim, obs = obs, type = "scatter", all_situations = FALSE)
# Only displaying the first situation for this one:
plots[[1]]
```

### 4.2. Plotting residuals

Residuals (Observed - Simulated values) can also be represented against observations:

```{r}
plots <- plot(
  sim,
  obs = obs,
  type = "scatter",
  select_scat = "res",
  all_situations = FALSE
)
# Only displaying the first situation again, but this time using its name:
plots$`SC_Pea_2005-2006_N0`
```

### 4.3. Grouping situations

All these data can also be represented with a single graph for all
situations:

```{r}
plot(sim, obs = obs, type = "scatter", all_situations = TRUE)
```

### 4.4. Reference variable on the x-axis

When plotting scatter plots, `reference_var` allows to choose
the reference variable on the x-axis. In this case the data provided (simulated or residuals) for all the different variables will be plotted against the observed,
simulated or residual values for this reference variable (to be chosen by suffixing the
variable name by "\_obs", "\_sim" or "\_res").

```{r}
plot(
  sim,
  obs = obs,
  type = "scatter",
  select_scat = "res",
  all_situations = TRUE,
  reference_var = "lai_n_sim"
)
```

### 4.5. Different shapes for situations

The points on the graphs can be shown in different shapes to
differentiate between situations when `all_situations = TRUE`. If
desired, the names of the situations can be displayed.

```{r}
plot(
  sim,
  obs = obs,
  type = "scatter",
  all_situations = TRUE,
  shape_sit = "txt"
)
```

As you can see, this can quickly become unreadable depending on the
number of points and length of situation names. That is why you can
simply assign a different symbol to each situation.

```{r}
plot(
  sim,
  obs = obs,
  type = "scatter",
  all_situations = TRUE,
  shape_sit = "symbol"
)
```

It is also possible to represent a group of situations with the same
symbol when, for example, clusters are identified.

```{r}
plot(
  sim,
  obs = obs,
  type = "scatter",
  all_situations = TRUE,
  shape_sit = "group",
  situation_group = list(list("SC_Pea_2005-2006_N0", "SC_Wheat_2005-2006_N0"))
)
```

You can also name your `situation_group` list and thus customize (e.g
shorten) the plot legend.

```{r}
plot(
  sim,
  obs = obs,
  type = "scatter",
  all_situations = TRUE,
  shape_sit = "group",
  situation_group = list(
    "Two Single Crops" = list("SC_Pea_2005-2006_N0", "SC_Wheat_2005-2006_N0")
  )
)
```

## 5. Comparing model versions

We can compare groups of simulations by simply adding the
simulations objects one after the other (that is why we have to explicitely name the `obs` argument). 
Group simulations can be the results of simulations from different model versions, or simulations with 
different parameter values.

Here's an example of a dynamic plot comparing the results obtained from two model versions:

```{r}
plot(sim, sim2, obs = obs, all_situations = FALSE)
```

There is one plot only here because `sim2` only contains one situation ("SC_Wheat_2005-2006_N0").

We can also name the corresponding group in the plot by naming them while passing to the `plot()` function:

```{r}
plot(
  original = sim,
  "New version" = sim2,
  obs = obs,
  type = "scatter",
  all_situations = FALSE
)
```

We can also compare groups of simulations with scatter plots:

```{r}
plot(
  original = sim,
  "New version" = sim2,
  obs = obs
)
```

## 6. Error bars

Error bars related to observations can also be added to the graph using
the `obs_sd` parameter which must be of the same shape as `obs`. In our
example, we will create a false data frame with the only purpose of
having a preview of the result. To have 95% confidence, the error bar is
equal to two standard deviations on each side of the point.

```{r}
obs_sd <- obs
names_obs <- names(obs_sd$`SC_Pea_2005-2006_N0`)
obs_sd$`SC_Pea_2005-2006_N0`[, !(names_obs %in% c("Date", "Plant"))] <-
  0.05 * obs_sd$`SC_Pea_2005-2006_N0`[, !(names_obs %in% c("Date", "Plant"))]
obs_sd$`SC_Wheat_2005-2006_N0`[, !(names_obs %in% c("Date", "Plant"))] <-
  0.2 * obs_sd$`SC_Wheat_2005-2006_N0`[, !(names_obs %in% c("Date", "Plant"))]

plot(sim, obs = obs, obs_sd = obs_sd, type = "scatter", all_situations = TRUE)
```

## 7. Intercrops

We can also plot intercrop situations. Here is an example of dynamic plots
with an intercrop situation:

```{r}
plot(sim_intercrop, obs = obs_intercrop)
```

And here is an example of scatter plots with an intercrop situation:

```{r}
plot(sim_intercrop, obs = obs_intercrop, type = "scatter", all_situations = TRUE)
```

## 8. Plot saving

The plots can be saved to disk using the `save_plot_png()` function as
follows:

```{r eval=FALSE}
plots <- plot("New version" = sim, original = sim2, obs = obs, type = "scatter")

save_plot_png(plot = plots, out_dir = "path/to/directory", suffix = "_scatter")

# or by piping:
plots <- plot(
  "New version" = sim,
  original = sim2,
  obs = obs,
  type = "scatter"
) %>%
  save_plot_png(., out_dir = "path/to/directory", suffix = "_scatter")
```

They can also be saved using the `save_plot_pdf()` function that which,
from a list of ggplots, generates a pdf file. If the `file_per_var`
parameter is TRUE, in this case the function generates one pdf file per
variable.

```{r eval=FALSE}
plots <- plot(sim, obs = obs)

save_plot_pdf(plot = plots, out_dir = "path/to/directory", file_per_var = FALSE)
```

## 9. Plot extraction

The plot function returns a named list of ggplot objects. The names of the
list correspond to the situations simulated:

```{r}
p <- plot(sim)

names(p)
```

To plot only one of the graph, access it using its name (with backticks if necessary):

```{r}
p$`SC_Wheat_2005-2006_N0`
```

or index it:

```{r, eval=FALSE}
p[[1]]
```

When we have plots with several variables and several situations, the
`extract_plot` function allows to keep the situations and variables that
we need.

In the following example, we want to extract the situation "SC_Wheat_2005-2006_N0" and
the "masec_n" variable.

```{r}
plots <- plot(sim, obs = obs, type = "scatter", all_situations = FALSE)

extract_plot(
  plots,
  situation = c("SC_Wheat_2005-2006_N0"), var = c("masec_n")
)
```

## 10. Statistics

### 10.1. Simple case

Here is an application of summary statistics:

```{r eval=FALSE}
summary(sim, obs = obs, all_situations = FALSE)
```

```{r echo=FALSE}
s <- summary(sim, obs = obs, all_situations = FALSE)
knitr::kable(s)
```

Note that as for the `plot()` function the `obs` argument is explicitly
named. This is because the first argument of the function is `...` to be
able to compare groups (i.e. model versions or simulation with different
parameter values).

And as for the `plot()` function again, it is possible to compute the
statistical criteria for all situations at once.

```{r eval=FALSE}
summary(sim, obs = obs, all_situations = TRUE)
```

```{r echo=FALSE}
s <- summary(sim, obs = obs, all_situations = TRUE)
knitr::kable(s)
```

### 10.2. Several groups

We can get statistics for each group of simulations by simply adding the
simulations objects one after the other (as for the `plot()` function).

```{r eval=FALSE}
summary(sim, sim2, obs = obs)
```

```{r echo=FALSE}
s <- summary(sim, sim2, obs = obs)
knitr::kable(s)
```

We can also name the corresponding group in the plot by naming them
while passing to the `summary()` function:

```{r eval=FALSE}
summary("New version" = sim, original = sim2, obs = obs)
```

```{r echo=FALSE}
s <- summary("New version" = sim, original = sim2, obs = obs)
knitr::kable(s)
```

By default, all statistics are returned by `summary`, but you can filter
them using the `stat` argument:

```{r eval=FALSE}
summary(
  "New version" = sim, original = sim2, obs = obs,
  stats = c("R2", "nRMSE")
)
```

```{r echo=FALSE}
s <- summary(
  "New version" = sim,
  original = sim2,
  obs = obs,
  stats = c("R2", "nRMSE")
)

knitr::kable(s)
```

For more details about the list of available statistical criterion and their definition, please read the help from [`predictor_assessment()`](https://sticsrpacks.github.io/CroPlotR/reference/predictor_assessment.html).

### 10.3. Statistics plot

It is also possible to plot the statistics:

In a rather obvious way, the resulting graph will take into account all
the situations simultaneously or not according to the parameter given to
`summary`. Here is an example with `all_situations = FALSE`.

```{r}
stats <- summary(
  "New version" = sim,
  original = sim2,
  obs = obs,
  stats = c("R2", "nRMSE"),
  all_situations = FALSE
)
plot(stats)
```

And here is an example with `all_situations = TRUE`.

```{r}
stats <- summary(
  "New version" = sim,
  original = sim2,
  obs = obs,
  stats = c("R2", "nRMSE"),
  all_situations = TRUE
)

plot(stats)
```

We can choose to plot either the group or the situation in x (and the
other is used for grouping and colouring):

```{r}
stats <- summary(
  "New version" = sim,
  original = sim2,
  obs = obs,
  stats = c("R2", "nRMSE"),
  all_situations = FALSE
)

plot(stats, xvar = "situation", title = "Situation in X")
```

In the previous examples, each line corresponds to a statistical
criterion. These can also be stacked.

```{r}
stats <- summary(
  "New version" = sim,
  original = sim2,
  obs = obs,
  stats = c("pMSEs", "pMSEu"),
  all_situations = FALSE
)

plot(stats, xvar = "situation", title = "Stacked columns", group_bar = "stack")
```

Or put side by side.

```{r}
stats <- summary(
  "New version" = sim,
  original = sim2,
  obs = obs,
  stats = c("pMSEs", "pMSEu"),
  all_situations = FALSE
)

plot(
  stats,
  xvar = "situation",
  title = "Side-by-side columns",
  group_bar = "dodge"
)
```

To compare different versions on a single criterion, the function
produces a radar graph like the following one.

```{r}
  (15 / 10) * sim$`SC_Pea_2005-2006_N0`$masec_n
sim$`SC_Wheat_2005-2006_N0`$mafruit <-
  (15 / 20) * sim$`SC_Wheat_2005-2006_N0`$masec_n
sim2$`IC_Wheat_Pea_2005-2006_N0`$mafruit <-
  sim2$`IC_Wheat_Pea_2005-2006_N0`$masec_n
obs$`IC_Wheat_Pea_2005-2006_N0`$mafruit <-
  (12 / 10) * obs$`IC_Wheat_Pea_2005-2006_N0`$masec_n
obs$`SC_Pea_2005-2006_N0`$mafruit <-
  (18 / 10) * obs$`SC_Pea_2005-2006_N0`$masec_n
obs$`SC_Wheat_2005-2006_N0`$mafruit <-
  (15 / 12) * obs$`SC_Wheat_2005-2006_N0`$masec_n

stats <- summary(
  "New version" = sim,
  original = sim2,
  obs = obs,
  stats = c("R2", "nRMSE"),
  all_situations = TRUE
)

plot(
  stats,
  type = "radar",
  crit_radar = "nRMSE",
  title = "Radar chart : nRMSE"
)
```

## 11. Data manipulation

Observation lists can easily be handled using e.g.
[dplyr](https://CRAN.R-project.org/package=dplyr),
[tidyr](https://CRAN.R-project.org/package=tidyr) or
[tibble](https://CRAN.R-project.org/package=tibble) packages.

The use of these packages on simulated data as returned by CroptimizR
model wrappers is sometimes prevented by their attribute
`cropr_simulation`. To easily manipulate simulated data we thus provide
two functions for (i) binding rows of data simulated on different
situations in a single data.frame or tibble and (ii) go back to the
original (cropr) format by splitting this single data.frame or tibble.

```{r}
df <- bind_rows(sim)
head(df)
```

The resulting data.frame/tibble can then easily be manipulated using
standard R packages. The column `situation` contains the name of the
corresponding situation (as given in the named list `sim`).

To go back to the original format of simulated data handled by CroPlotR,
use the `split_df2sim` function:

```{r}
sim_new <- split_df2sim(df)
lapply(sim_new, head)
```

## 12. Tools

### 12.1. Interactivity with ggplotly

The ggplotly function in plotly library makes it very easy to create
interactive graphics from a ggplot. Do not hesitate to call it with your
plot and move your mouse over the graph to discover the features of this
function.

```{r, eval = FALSE}
library(plotly)

ggplotly(plot(sim, obs = obs, type = "dynamic")[[1]])
```

### 12.2. Combining plots with patchwork

There is also the patchwork library that allows you to easily combine
several ggplot into one.

```{r}
library(patchwork)

plot1 <- plot(sim, obs = obs, type = "scatter", var = "lai_n")[[1]]
plot2 <- plot(sim, obs = obs, var = "lai_n")[[1]]
plot3 <- plot(sim, obs = obs, type = "scatter", var = "masec_n")[[1]]
plot4 <- plot(sim, obs = obs, var = "masec_n")[[1]]

plot1 + plot2 + plot3 + plot4 + plot_layout(ncol = 2)
```

## 13. Data structure

The `sim` and `obs` objects are named lists of `data.frame`s. Each element of
the list corresponds to a situation (a crop in a given year with a given management). Each `data.frame` contains the simulated or observed variables for this situation.

Here's the structure of the `sim` object:

```{r}
lapply(sim, head)
```

The structure of the `obs` object is similar:

```{r}
lapply(obs, head)
```

Note that the simulation structure is a special structure called `cropr_simulation`. You can easily make such an object from a named list of data.frames, and giving 
the class attribute `cropr_simulation`, e.g.:

```{r}
sim_test <- list(
  situation_1 = data.frame(
    Date = as.Date("2000-01-01") + 0:9,
    var1 = rnorm(10),
    var2 = rnorm(10)
  ),
  situation_2 = data.frame(
    Date = as.Date("2001-01-01") + 0:9,
    var1 = rnorm(10),
    var2 = rnorm(10)
  )
)

class(sim_test) <- append(class(sim_test), "cropr_simulation")
head(sim_test)
```

## 14. Finding help

You can find help for the functions directly using the name of the
function followed by the class of the object you need the method for:

-   plot:

```{r eval=FALSE}
?plot.cropr_simulation

?plot.statistics
```

-   statistics:

```{r eval=FALSE}
?summary.cropr_simulation
```

If you have any problem, please [fill an
issue](https://github.com/SticsRPacks/CroPlotR/issues) on Github.

## 15. Citation

If you have used this package for a study that led to a publication or
report, please cite us. You can either use the citation tool from Github
if you used the last version, or use `citation("CroPlotR")` from R
otherwise.
