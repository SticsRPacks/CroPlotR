---
output: github_document
editor_options: 
  chunk_output_type: console
  markdown: 
    wrap: 72
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# CroPlotR

<!-- badges: start -->

[![Codecov test
coverage](https://codecov.io/gh/SticsRPacks/CroPlotR/branch/master/graph/badge.svg)](https://app.codecov.io/gh/SticsRPacks/CroPlotR?branch=master)
[![R-CMD-check](https://github.com/SticsRPacks/CroPlotR/actions/workflows/check-standard.yaml/badge.svg?branch=main)](https://github.com/SticsRPacks/CroPlotR/actions/workflows/check-standard.yaml)
[![DOI](https://zenodo.org/badge/263962392.svg)](https://zenodo.org/badge/latestdoi/263962392)

<!-- badges: end -->

`CroPlotR` aims at the standardization of the process of analyzing the outputs from crop models such as 
[STICS](https://www6.paca.inrae.fr/stics_eng/), [APSIM](https://www.apsim.info/) or really any model.

Its use does not need any particular adaptation if your model has been wrapped with the 
[CroptimizR](https://github.com/SticsRPacks/CroptimizR) package thanks to the use of the `cropr_simulation` standard of data representation (see section below).

If you want to be notified when a new release of this package is made, you can tick the Releases box in the "Watch / Unwatch =\> Custom" menu
at the top right of [this page](https://github.com/SticsRPacks/CroPlotR).

## Table of Contents


- [CroPlotR](#croplotr)
  - [Table of Contents](#table-of-contents)
  - [Installation](#installation)
  - [Introduction](#introduction)
  - [Dynamic plots](#dynamic-plots)
    - [Simple dynamic plot](#simple-dynamic-plot)
    - [Observations](#observations)
    - [Filter variables](#filter-variables)
    - [Successive situations](#successive-situations)
    - [Overlaying variables](#overlaying-variables)
  - [Scatter plots](#scatter-plots)
    - [Simple scatter plot](#simple-scatter-plot)
    - [Plotting residuals](#plotting-residuals)
    - [Grouping situations](#grouping-situations)
    - [Reference variable on the x-axis](#reference-variable-on-the-x-axis)
    - [Different shapes for situations](#different-shapes-for-situations)
  - [Comparing model versions](#comparing-model-versions)
  - [Error bars](#error-bars)
  - [Intercrops](#intercrops)
  - [Plot saving](#plot-saving)
  - [Plot extraction](#plot-extraction)
  - [Statistics](#statistics)
    - [Simple case](#simple-case)
    - [Several groups](#several-groups)
    - [Statistics plot](#statistics-plot)
  - [Data manipulation](#data-manipulation)
  - [Tools](#tools)
    - [Interactivity with ggplotly](#interactivity-with-ggplotly)
    - [Combining plots with patchwork](#combining-plots-with-patchwork)
  - [Data structure](#data-structure)
  - [Finding help](#finding-help)
  - [Citation](#citation)

## Installation

You can install the released version of CroPlotR from [Github](https://github.com/SticsRPacks/CroPlotR) either using
`devtools` or the more lightweight `remotes` package:

-   With `devtools`

```{r eval=FALSE}
devtools::install_github("SticsRPacks/CroPlotR@*release")
```

-   With `remotes`

```{r eval=FALSE}
# install.packages("remotes")
remotes::install_github("SticsRPacks/CroPlotR@*release")
```

## Introduction

Only one function is exported for plots [`plot()`](https://sticsrpacks.github.io/CroPlotR/reference/plot.cropr_simulation.html)
(and its alias `autoplot()`), and one for the statistics [`summary()`](https://sticsrpacks.github.io/CroPlotR/reference/summary.cropr_simulation.html).
These functions should be the only one you need for all your plots and summary statistics. Additional ones are provided to simplify the
manipulation of simulated data (see [2.3 Data manipulation](#23-data-manipulation)).

In the following, an example using the STICS crop model is presented. If you want to use another model for which a wrapper has been designed for
the [CroptimizR](https://github.com/SticsRPacks/CroptimizR) package, just consider defining the `sim` variable used in the examples below as
`sim <- result$sim_list`, where `result` is the list returned by your model wrapper. Examples of use of CroPlotR with Stics and APSIM model
wrappers can be found in [CroptimizR's website](https://sticsrpacks.github.io/CroptimizR/) (see Articles tab).

In the following examples, we use the `sim` and `obs` objects, which contains a simulation of two situations:

-   a Pea in sole crop
-   a Wheat in sole crop

We also use an intercrop situation with Wheat and Pea together, stored in `sim_intercrop` and `obs_intercrop`.

<details><summary>Code to import the data</summary>

To reproduce the data used in this file, you can use the following code snippet. It will import the data from an example simulation from the STICS model.

```{r, include = FALSE}
# Importing an example with three situations with observation:
workspace <- system.file(
  file.path("extdata", "stics_example_1"),
  package = "CroPlotR"
)

situations <- SticsRFiles::get_usms_list(
  file = file.path(workspace, "usms.xml")
)

usms_sole_crop <- c("SC_Pea_2005-2006_N0", "SC_Wheat_2005-2006_N0")
usms_intercrop <- c("IC_Wheat_Pea_2005-2006_N0")

sim <- SticsRFiles::get_sim(
  workspace = workspace,
  usms_file = file.path(workspace, "usms.xml"),
  usm = usms_sole_crop
)

sim_intercrop <- SticsRFiles::get_sim(
  workspace = workspace,
  usms_file = file.path(workspace, "usms.xml"),
  usm = usms_intercrop
)

obs <- SticsRFiles::get_obs(
  workspace = workspace,
  usm = usms_sole_crop,
  usms_file = file.path(workspace, "usms.xml")
)

obs_intercrop <- SticsRFiles::get_obs(
  workspace = workspace,
  usm = usms_intercrop,
  usms_file = file.path(workspace, "usms.xml")
)

workspace_2 <- system.file(
  file.path("extdata", "stics_example_successive"),
  package = "CroPlotR"
)

situations <- SticsRFiles::get_usms_list(
  file = file.path(workspace_2, "usms.xml")
)

sim_rot <- SticsRFiles::get_sim(
  workspace = workspace_2,
  usm = situations,
  usms_file = file.path(workspace_2, "usms.xml")
)

sim2 <- sim[2]
# Generate randomness around lai_n and masec_n for the second simulation
set.seed(123)
for (sit in names(sim2)) {
  sim2[[sit]]$lai_n <- sim[[sit]]$lai_n * (1.1 + rnorm(nrow(sim2[[sit]]), mean = 0, sd = 0.01))
  sim2[[sit]]$masec_n <- sim[[sit]]$masec_n * (1.1 + rnorm(nrow(sim2[[sit]]), mean = 0, sd = 0.01))
}

# Write a .RData file for reproducibility for the users
save(
  sim, sim2, sim_intercrop, obs, obs_intercrop, sim_rot,
  file = "inst/extdata/readme_sim_obs_example.RData"
)
```

```{r}
library(CroPlotR)
rdata_path <- system.file(file.path("extdata", "readme_sim_obs_example.RData"), package = "CroPlotR")
load(rdata_path)
```

</details>

## Dynamic plots

### Simple dynamic plot

Here is an application of dynamic plots for two example situations:

```{r}
plot(sim)
```

### Observations

We can also add observations to the dynamic plots by passing the `obs` argument:

```{r}
plot(sim, obs = obs)
```

Note that it is mandatory to explicitly name the `obs` argument (`obs = ...`).

### Filter variables

By default, all variables are returned by `plot()`, but you can filter them using the `var` argument:

```{r}
plot(sim, obs = obs, var = c("lai_n"))
```

### Successive situations

It is possible to aggregate plots of multiple situations on the same
graph when situations follow one another over time. This can be done
using the `successive` parameter:

```{r}
plot(
  sim_rot,
  var = c("resmes", "masec_n"),
  successive = list(list("demo_Wheat1", "demo_BareSoil2", "demo_maize3"))
)
```

### Overlaying variables

We can also overlay variables thanks to the "overlap" parameter with
dynamic plots.

```{r}
plot(sim, obs = obs, overlap = list(list("lai_n", "masec_n")))
```

> Note that it is not possible to scale the variables right now from the
> plot function (see
> [issue](https://github.com/SticsRPacks/CroPlotR/issues/2)). If you
> want to do so, you are encouraged to scale before the plotting
> function, and to add a second axis using
> [sec_axis](https://ggplot2.tidyverse.org/reference/sec_axis.html) on
> the resulting plot.

## Scatter plots

### Simple scatter plot

Here are the same plots, but presented as scatter plots:

```{r}
# Only plotting the first situation for this one:
plots <- plot(sim, obs = obs, type = "scatter", all_situations = FALSE)
plots$`SC_Pea_2005-2006_N0`
```

### Plotting residuals

Residuals can also be represented against observations:

```{r}
# Only plotting the first situation again:
plots <- plot(
  sim,
  obs = obs,
  type = "scatter",
  select_scat = "res",
  all_situations = FALSE
)

plots[[1]]
```

### Grouping situations

All these data can also be represented with a single graph for all
situations:

```{r}
plot(sim, obs = obs, type = "scatter", all_situations = TRUE)
```

### Reference variable on the x-axis

When plotting residual scatter plots, `reference_var` allows to choose
the reference variable on the x-axis. Thus, the observations or
simulations of this reference variable (to be chosen by suffixing the
variable name by "\_obs" or "\_sim") will be compared to the residuals
of each of the variables.

```{r}
plot(
  sim,
  obs = obs,
  type = "scatter",
  select_scat = "res",
  all_situations = TRUE,
  reference_var = "lai_n_sim"
)
```

### Different shapes for situations

The points on the graphs can be shown in different shapes to
differentiate between situations when `all_situations = TRUE`. If
desired, the names of the situations can be displayed.

```{r}
plot(
  sim,
  obs = obs,
  type = "scatter",
  all_situations = TRUE,
  shape_sit = "txt"
)
```

As you can see, this can quickly become unreadable depending on the
number of points and length of situation names; That is why you can
simply assign a different symbol to each situation.

```{r}
plot(
  sim,
  obs = obs,
  type = "scatter",
  all_situations = TRUE,
  shape_sit = "symbol"
)
```

It is also possible to represent a group of situations with the same
symbol when, for example, clusters are identified.

```{r}
plot(
  sim,
  obs = obs,
  type = "scatter",
  all_situations = TRUE,
  shape_sit = "group",
  situation_group = list(list("SC_Pea_2005-2006_N0", "SC_Wheat_2005-2006_N0"))
)
```

You can also name your `situation_group` list and thus customize (e.g
shorten) the plot legend.

```{r}
plot(
  sim,
  obs = obs,
  type = "scatter",
  all_situations = TRUE,
  shape_sit = "group",
  situation_group = list(
    "Two Single Crops" = list("SC_Pea_2005-2006_N0", "SC_Wheat_2005-2006_N0")
  )
)
```

## Comparing model versions

We can compare groups of simulations by simply adding the
simulations objects one after the other (that is why we have to explicitely name the `obs` argument). 
Group simulations can be the results of simulations from different model versions, or simulations with 
different parameter values.

Here's an example of a dynamic plot comparing two model versions:

```{r}
plot(sim, sim2, obs = obs, all_situations = FALSE)
```

There is one plot only here because `sim2` only contains one situation ("SC_Wheat_2005-2006_N0").

We can also name the corresponding group in the plot by naming them while passing to the `plot()` function:

```{r}
plot(
  original = sim,
  "New version" = sim2,
  obs = obs,
  type = "scatter",
  all_situations = FALSE
)
```

We can also compare groups of simulations with scatter plots:

```{r}
plot(
  original = sim,
  "New version" = sim2,
  obs = obs,
  type = "scatter",
  all_situations = FALSE
)
```

## Error bars

Error bars related to observations can also be added to the graph using
the `obs_sd` parameter which must be of the same shape as `obs`. In our
example, we will create a false data frame with the only purpose of
having a preview of the result. To have 95% confidence, the error bar is
equal to two standard deviations on each side of the point.

```{r}
obs_sd <- obs
names_obs <- names(obs_sd$`SC_Pea_2005-2006_N0`)
obs_sd$`SC_Pea_2005-2006_N0`[, !(names_obs %in% c("Date", "Plant"))] <-
  0.05 * obs_sd$`SC_Pea_2005-2006_N0`[, !(names_obs %in% c("Date", "Plant"))]
obs_sd$`SC_Wheat_2005-2006_N0`[, !(names_obs %in% c("Date", "Plant"))] <-
  0.2 * obs_sd$`SC_Wheat_2005-2006_N0`[, !(names_obs %in% c("Date", "Plant"))]

plot(sim, obs = obs, obs_sd = obs_sd, type = "scatter", all_situations = TRUE)
```

## Intercrops

We can also plot intercrop situations. Here is an example of dynamic plots
with an intercrop situation:

```{r}
plot(sim_intercrop, obs = obs_intercrop)
```

And here is an example of scatter plots with an intercrop situation:

```{r}
plot(sim_intercrop, obs = obs_intercrop, type = "scatter", all_situations = TRUE)
```

## Plot saving

The plots can be saved to disk using the `save_plot_png()` function as
follows:

```{r eval=FALSE}
plots <- plot("New version" = sim, original = sim2, obs = obs, type = "scatter")

save_plot_png(plot = plots, out_dir = "path/to/directory", suffix = "_scatter")

# or by piping:
plots <- plot(
  "New version" = sim,
  original = sim2,
  obs = obs,
  type = "scatter"
) %>%
  save_plot_png(., out_dir = "path/to/directory", suffix = "_scatter")
```

They can also be saved using the `save_plot_pdf()` function that which,
from a list of ggplots, generates a pdf file. If the `file_per_var`
parameter is TRUE, in this case the function generates one pdf file per
variable.

```{r eval=FALSE}
plots <- plot(sim, obs = obs)

save_plot_pdf(plot = plots, out_dir = "path/to/directory", file_per_var = FALSE)
```

## Plot extraction

The plot function returns a named list of ggplot objects. The names of the
list correspond to the situations simulated:

```{r}
p <- plot(sim)

names(p)
```

To plot only one of the graph, access it using its name (with backticks if necessary):

```{r}
p$`SC_Wheat_2005-2006_N0`
```

or index it:

```{r, eval=FALSE}
p[[1]]
```

When we have plots with several variables and several situations, the
`extract_plot` function allows to keep the situations and variables that
we need.

In the following example, we want to extract the intercrop situation and
the "masec_n" variable.

```{r}
plots <- plot(sim, obs = obs, type = "scatter", all_situations = FALSE)

extract_plot(
  plots,
  situation = c("SC_Wheat_2005-2006_N0"), var = c("masec_n")
)
```

## Statistics

### Simple case

Here is an application of summary statistics for the 3 situations:

```{r eval=FALSE}
summary(sim, obs = obs, all_situations = FALSE)
```

```{r echo=FALSE}
s <- summary(sim, obs = obs, all_situations = FALSE)
knitr::kable(s)
```

Note that as for the `plot()` function the `obs` argument is explicitly
named. This is because the first argument of the function is `...` to be
able to compare groups (i.e. model versions or simulation with different
parameter values). In this example, a message warns the user because
some observed values have a zero value which causes a division by zero
in the calculation of certain statistical criteria, these values are
therefore filtered for the calculation of these criteria.

And as for the `plot()` function again, it is possible to compute the
statistical criteria for all situations at once.

```{r eval=FALSE}
summary(sim, obs = obs, all_situations = TRUE)
```

```{r echo=FALSE}
s <- summary(sim, obs = obs, all_situations = TRUE)
knitr::kable(s)
```

### Several groups

We can get statistics for each group of simulations by simply adding the
simulations objects one after the other (as for the `plot()` function).

```{r eval=FALSE}
summary(sim, sim2, obs = obs)
```

```{r echo=FALSE}
s <- summary(sim, sim2, obs = obs)
knitr::kable(s)
```

We can also name the corresponding group in the plot by naming them
while passing to the `summary()` function:

```{r eval=FALSE}
summary("New version" = sim, original = sim2, obs = obs)
```

```{r echo=FALSE}
s <- summary("New version" = sim, original = sim2, obs = obs)
knitr::kable(s)
```

By default, all statistics are returned by `summary`, but you can filter
them using the `stat` argument:

```{r eval=FALSE}
summary(
  "New version" = sim, original = sim2, obs = obs,
  stats = c("R2", "nRMSE")
)
```

```{r echo=FALSE}
s <- summary(
  "New version" = sim,
  original = sim2,
  obs = obs,
  stats = c("R2", "nRMSE")
)

knitr::kable(s)
```

Please read the help from
[`summary.cropr_simulation()`](https://sticsrpacks.github.io/CroPlotR/reference/summary.cropr_simulation.html)
and
[`predictor_assessment()`](https://sticsrpacks.github.io/CroPlotR/reference/predictor_assessment.html).

### Statistics plot

It is also possible to plot the statistics:

In a rather obvious way, the resulting graph will take into account all
the situations simultaneously or not according to the parameter given to
`summary`. Here is an example with `all_situations = FALSE`.

```{r}
stats <- summary(
  "New version" = sim,
  original = sim2,
  obs = obs,
  stats = c("R2", "nRMSE"),
  all_situations = FALSE
)
plot(stats)
```

And here is an example with `all_situations = TRUE`.

```{r}
stats <- summary(
  "New version" = sim,
  original = sim2,
  obs = obs,
  stats = c("R2", "nRMSE"),
  all_situations = TRUE
)

plot(stats)
```

We can choose to plot either the group or the situation in x (and the
other is used for grouping and colouring):

```{r}
stats <- summary(
  "New version" = sim,
  original = sim2,
  obs = obs,
  stats = c("R2", "nRMSE"),
  all_situations = FALSE
)

plot(stats, xvar = "situation", title = "Situation in X")
```

In the previous examples, each line corresponds to a statistical
criterion. These can also be stacked.

```{r}
stats <- summary(
  "New version" = sim,
  original = sim2,
  obs = obs,
  stats = c("pMSEs", "pMSEu"),
  all_situations = FALSE
)

plot(stats, xvar = "situation", title = "Stacked columns", group_bar = "stack")
```

Or put side by side.

```{r}
stats <- summary(
  "New version" = sim,
  original = sim2,
  obs = obs,
  stats = c("pMSEs", "pMSEu"),
  all_situations = FALSE
)

plot(
  stats,
  xvar = "situation",
  title = "Side-by-side columns",
  group_bar = "dodge"
)
```

To compare different versions on a single criterion, the function
produces a radar graph like the following one.

```{r}
sim$`SC_Pea_2005-2006_N0`$mafruit <-
  (15 / 10) * sim$`SC_Pea_2005-2006_N0`$masec_n
sim$`SC_Wheat_2005-2006_N0`$mafruit <-
  (15 / 20) * sim$`SC_Wheat_2005-2006_N0`$masec_n
sim2$`IC_Wheat_Pea_2005-2006_N0`$mafruit <-
  sim2$`IC_Wheat_Pea_2005-2006_N0`$masec_n
obs$`IC_Wheat_Pea_2005-2006_N0`$mafruit <-
  (12 / 10) * obs$`IC_Wheat_Pea_2005-2006_N0`$masec_n
obs$`SC_Pea_2005-2006_N0`$mafruit <-
  (18 / 10) * obs$`SC_Pea_2005-2006_N0`$masec_n
obs$`SC_Wheat_2005-2006_N0`$mafruit <-
  (15 / 12) * obs$`SC_Wheat_2005-2006_N0`$masec_n

stats <- summary(
  "New version" = sim,
  original = sim2,
  obs = obs,
  stats = c("R2", "nRMSE"),
  all_situations = TRUE
)

plot(
  stats,
  type = "radar",
  crit_radar = "nRMSE",
  title = "Radar chart : nRMSE"
)
```

## Data manipulation

Observation lists can easily be handled using e.g.
[dplyr](https://CRAN.R-project.org/package=dplyr),
[tidyr](https://CRAN.R-project.org/package=tidyr) or
[tibble](https://CRAN.R-project.org/package=tibble) packages.

The use of these packages on simulated data as returned by CroptimizR
model wrappers is sometimes prevented by their attribute
`cropr_simulation`. To easily manipulate simulated data we thus provide
two functions for (i) binding rows of data simulated on different
situations in a single data.frame or tibble and (ii) go back to the
original (cropr) format by splitting this single data.frame or tibble.

```{r}
df <- bind_rows(sim)
head(df)
```

The resulting data.frame/tibble can then easily be manipulated using
standard R packages. The column `situation` contains the name of the
corresponding situation (as given in the named list `sim`).

To go back to the original format of simulated data handled by CroPlotR,
use the `split_df2sim` function:

```{r}
sim_new <- split_df2sim(df)
lapply(sim_new, head)
```

## Tools

### Interactivity with ggplotly

The ggplotly function in plotly library makes it very easy to create
interactive graphics from a ggplot. Do not hesitate to call it with your
plot and move your mouse over the graph to discover the features of this
function.

```{r, eval = FALSE}
library(plotly)

ggplotly(plot(sim, obs = obs, type = "dynamic")[[1]])
```

### Combining plots with patchwork

There is also the patchwork library that allows you to easily combine
several ggplot into one.

```{r}
library(patchwork)

plot1 <- plot(sim, obs = obs, type = "scatter", var = "lai_n")[[1]]
plot2 <- plot(sim, obs = obs, var = "lai_n")[[1]]
plot3 <- plot(sim, obs = obs, type = "scatter", var = "masec_n")[[1]]
plot4 <- plot(sim, obs = obs, var = "masec_n")[[1]]

plot1 + plot2 + plot3 + plot4 + plot_layout(ncol = 2)
```

## Data structure

The `sim` and `obs` objects are named lists of `data.frame`s. Each element of
the list corresponds to a situation (a crop in a given year with a given management). Each `data.frame` contains the simulated or observed variables for this situation.

Here's the structure of the `sim` object:

```{r}
lapply(sim, head)
```

The structure of the `obs` object is similar:

```{r}
lapply(obs, head)
```

Note that the simulation structure is a special structure called `cropr_simulation`. You can easily make such an object from a named list of data.frames, and giving 
the class attribute `cropr_simulation`, e.g.:

```{r}
sim_test <- list(
  situation_1 = data.frame(
    Date = as.Date("2000-01-01") + 0:9,
    var1 = rnorm(10),
    var2 = rnorm(10)
  ),
  situation_2 = data.frame(
    Date = as.Date("2001-01-01") + 0:9,
    var1 = rnorm(10),
    var2 = rnorm(10)
  )
)

class(sim_test) <- append(class(sim_test), "cropr_simulation")
```

## Finding help

You can find help for the functions directly using the name of the
function followed by the class of the object you need the method for:

-   plot:

```{r eval=FALSE}
?plot.cropr_simulation

?plot.statistics
```

-   statistics:

```{r eval=FALSE}
?summary.cropr_simulation
```

If you have any problem, please [fill an
issue](https://github.com/SticsRPacks/CroPlotR/issues) on Github.

## Citation

If you have used this package for a study that led to a publication or
report, please cite us. You can either use the citation tool from Github
if you used the last version, or use `citation("CroPlotR")` from R
otherwise.
